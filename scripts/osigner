#!/usr/bin/env python
#
# osigner - offline (cold) wallet signer utility
# Copyright (C) 2013 TradeHill Inc
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.

import re
import pkgutil
import sys, os, time, json
from os import path
from glob import glob
import optparse
import platform
from decimal import Decimal

try:
    import ecdsa  
except ImportError:
    sys.exit("Error: python-ecdsa does not seem to be installed. Try 'sudo pip install ecdsa'")

try:
    import aes
except ImportError:
    sys.exit("Error: AES does not seem to be installed. Try 'sudo pip install slowaes'")


is_local = os.path.dirname(os.path.realpath(__file__)) == os.path.join(os.getcwd(), 'scripts')
is_android = 'ANDROID_DATA' in os.environ

import __builtin__
__builtin__.use_local_modules = is_local or is_android

# load local module as electrum
if __builtin__.use_local_modules:
    import imp
    imp.load_module('electrum', *imp.find_module('../lib'))
    imp.load_module('electrum_gui', *imp.find_module('../gui'))
    imp.load_module('scripts_gui', *imp.find_module('gui'))


from electrum import *

def arg_parser():
    usage = """usage: %prog [options] DIR ...
Signs all unsigned transactions files of the form *.txn in each directory.
The signed transactions are of the form *.stxn.
After signing, each unsigned file is moved into an archive subdirectory.
""" 
    parser = optparse.OptionParser(prog=usage)
    parser.add_option("-w", "--wallet", dest="wallet_path", help="wallet path (default: electrum.dat)")
    parser.add_option("-v", "--verbose", action="store_true", dest="verbose", default=False, help="show debugging information")
    parser.add_option("-g", "--gui", dest="gui", help="User interface: qt, lite, gtk or text")
    return parser

def print_outputs(outs, classes):
    for idx, out in enumerate(outs):
        classification = classes[idx]
        address, amount = out
        output_info = outs[idx]
        print "    %s:%s -> %s"%(classification, util.format_satoshis(amount, False), address)

class TxScanner:
    def __init__(self, dirs):
        self.dirs = dirs
        self.scan()

    def compute_paths(self, tx_file):
        archive_dir = path.join(path.dirname(tx_file), 'archive')
        (base, ignore) = path.splitext(tx_file)
        bare_base = re.sub('-part$', '', base)
        signed_file = bare_base + '.stxn'
        partial_file = base + '-part.txn'
        archived_file = path.join(archive_dir, path.basename(tx_file))
        archived_signed_file = path.join(archive_dir, path.basename(signed_file))
        return (signed_file, partial_file, archived_file, archived_signed_file)

    def result_file(self, tx, is_complete):
        (signed_file, partial_file, archived_file, archived_signed_file) = self.compute_paths(tx['file'])
        return signed_file if is_complete else partial_file

    def archived_file(self, tx, is_complete):
        (signed_file, partial_file, archived_file, archived_signed_file) = self.compute_paths(tx['file'])
        return archived_file

    def classify_outputs(self, outs, wallet, output_infos):
        types = []
        for idx, out in enumerate(outs):
            address, amount = out
            if output_infos and output_infos[idx]:
                print output_infos[idx]
                account, type, seq = output_infos[idx]
                if address == wallet.accounts[account].get_address(*seq):
                    types.append('CHANGE')
                else:
                    types.append('INVALID')
            else:
                types.append('OUTPUT')
        return types

    def scan(self):
        tx_files = []
        for tx_dir in self.dirs:
            tx_files = tx_files + glob(path.join(tx_dir, '*.txn'))
            tx_files = tx_files + glob(path.join(tx_dir, '*.stxn'))
            tx_files = tx_files + glob(path.join(tx_dir, 'archive', '*.txn'))
            tx_files = tx_files + glob(path.join(tx_dir, 'archive', '*.stxn'))
            archive_dir = path.join(tx_dir, 'archive')
            if not path.isdir(archive_dir):
                os.mkdir(archive_dir)

        tx_files.sort()

        txs = []
        for tx_file in tx_files:
            (signed_file, partial_file, archived_file, archived_signed_file) = self.compute_paths(tx_file)
            tx = json.load(open(tx_file, "rb"))
            if path.commonprefix([tx_file, archive_dir]) != archive_dir:
                if path.isfile(signed_file) and signed_file != tx_file:
                    print "%s already exists (for %s)!"%(signed_file, tx_file)
                    sys.exit(1)
                if path.isfile(archived_file):
                    print "Archived unsigned file %s already exists!"%(archived_file)
                    sys.exit(1)
                if path.isfile(archived_signed_file):
                    print "Archived signed file %s already exists!"%(archived_signed_file)
                    sys.exit(1)
                tx['archived'] = False
            else:
                tx['archived'] = True

            tx['file'] = tx_file
            tx['created'] = path.getmtime(tx_file)
            txs.append(tx)
        self.txs = txs
    def sign(self, unsigned_tx):
        raw_tx = unsigned_tx['hex']
        input_info = json.loads(unsigned_tx['input_info'])
        tx = Transaction(raw_tx)
        tx.output_info = json.loads(unsigned_tx['output_info'])
        addresses = map( lambda o: o[0], tx.outputs )
        #wallet.synchronize_offline(addresses)

        print_outputs(tx.outputs, self.classify_outputs(tx.outputs, wallet, tx.output_info))
        signed = wallet.signrawtransaction(tx, input_info, [], None)
        if not signed:
            return False
        out_file = scanner.result_file(unsigned_tx, tx.is_complete)
        archived_file = self.archived_file(unsigned_tx, tx.is_complete)
        f = open(out_file, "wb")
        f.write(json.dumps(tx.as_dict()))
        f.write("\n")
        f.close()
        print "Created %s"%(out_file)
        os.rename(unsigned_tx['file'], archived_file)
        print
        return True

def cli(scanner, options):
    for unsigned_tx in scanner.txs:
        if unsigned_tx['complete'] or unsigned_tx['archived']:
            continue
        print unsigned_tx['file'] + ":"
        raw_tx = unsigned_tx['hex']
        tx = Transaction(raw_tx)
        tx.output_info = json.loads(unsigned_tx['output_info'])
        addresses = map( lambda o: o[0], tx.outputs )
        #wallet.synchronize_offline(addresses)

        print_outputs(tx.outputs, scanner.classify_outputs(tx.outputs, wallet, tx.output_info))
        out_file = scanner.result_file(unsigned_tx, tx.is_complete)
        archived_file = scanner.archived_file(unsigned_tx, tx.is_complete)
        if not raw_input('Sign this transaction? ').startswith('y'):
            sys.exit(0)
        scanner.sign(unsigned_tx)

if __name__ == '__main__':

    parser = arg_parser()
    options, args = parser.parse_args()
    set_verbosity(options.verbose)

    # config is an object passed to the various constructors (wallet, interface, gui)
    if is_android:
        config_options = {'wallet_path':"/sdcard/electrum.dat", 'portable':True, 'verbose':True, 'gui':'android', 'auto_cycle':True}
    else:
        config_options = eval(str(options))
        for k, v in config_options.items():
              if v is None: config_options.pop(k)

    config = SimpleConfig(config_options)
    wallet = Wallet(config)

    if not config.wallet_file_exists:
        print_msg("Error: Wallet file not found.")
        sys.exit(1)

    scanner = TxScanner(args)
    gui_name = config.get('gui')
    if gui_name is None:
        cli(scanner, options)
    else:
        try:
            gui = __import__('scripts_gui.osigner_' + gui_name, fromlist=['scripts_gui'])
        except ImportError:
            sys.exit("Error: Unknown GUI: " + gui_name )
        
        interface = Interface(config, True)
        verifier = WalletVerifier(interface, config)
        verifier.start()
        wallet.set_verifier(verifier)
        gui = gui.OsignerGui(wallet, config, scanner)
        gui.main()
